make_input_202009161249
テストケース生成
・path= パスとファイル名指定
・ナンバリングでa~b-1を作る
　　※15ファイルくらいでメモリエラーが出る
・problem=でA,Bの書き込みをする
・end at ~~で時間計測を出力する

check_input_2020091649
input_00~input_nnをチェックする
・パス指定可能
・Aのみ実装済み
・間違っていたら間違った部分とファイルを指摘してくれる(多分)

これからの予定。
・メイン関数を実装。A,B
・A,B共通で使えるように、時刻tまでの注文情報から時刻tの行動を決定することを考える
・テストケースで試せるようなインプットを作る
・評価関数を作る
・Aのみで動く、全注文から決定するもの
・Bのみで動く、注文頻度を参考にするもの
の2通りを別で作る。

１．各頂点から各頂点への最短経路を記録する
（ダイクストラ＊４００）（メモリ：４００＾３以下）

２．現在いる頂点からどの頂点へ向かうか
各頂点について最短経路を通った場合のスコアの増分を、時間逓減させながら和を取る
※ただし、頂点0：店舗に関しては別のパラメータで評価する必要がある
※各頂点から店舗への距離も評価対象としたい
もっとも評価の高い頂点へ向かうよう、経路を決定する。ただし次の頂点へ到達したら再計算したほうが良いかも

３．辺の上にいるとき引き返すか
いまの目的地へ向かうか、店舗へ向かう（引き返すか）を選択する
ここのパラメータミスるとスコア下がりそう。
店舗へ向かっている場合引き返さない

４．まとめ
店舗へ向かっている：そのまま向かう
頂点にいる：全頂点を評価してルート決定
辺にいる　：注文数から、いまのルートを進む、進んで店舗へ向かう、引き返して店舗へ向かうの3択

持つべき情報
a.注文時刻→注文ID
b.各頂点の注文時刻集合
c.各頂点で荷物を持っている注文時刻の和、平方和
d.各頂点で荷物を持っていない注文時刻の和、平方和
c0.荷物を持っている注文の和、平方和
d0.荷物を持っていない注文の和、平方和

a,bは注文を受け取った際、各頂点で配達を完了した際に更新。主にBで使う
cとc0、dとd0は店舗顧客でわけて同じベクトルでよい

・メイン関数をファイル数回して、評価する
・メイン関数の提出用の実装（特にBはめんどくさそう）
if not debug:
　　インタラクティブな入出力
これを書いておけば大体OK
完了した注文や、積んでいる注文など、注文IDを間違えないように注意する。
特に、注文を受けた時刻だけ記録してIDを記録していないなどのミスが考えられる

問題Bの大きな違い
・注文があらかじめ与えられない
・ただし注文頻度が与えられる。

各時刻（０～Tmax-1）でのフロー
時刻tの最後
　　注文を受け取る
　　商品を積む
　　行動を決定する
時刻t+1の最初
　　商品を届ける
　　スコアの算出


    "https://atcoder.jp/contests/hokudai-hitachi2019-1"
    Hitachi Hokudai Labo & Hokkaido University Contest 2019-1
    での入力ファイル作成のプログラム（途中）と考察

・基本的な計画
１．テストケースの作成
問題A、Bに基づくテストケースを作成する関数を作る
30個ずつ、V、Eの値を調整できるようにするとなお良し
問題A、Bの分岐は書き出しだけで良さそう


２．メインプログラム
手元用：テストケースの読み込み
提出用：入力の読み込み
で2通り用意する。
問題A、Bで更に2通り用意する



    １．入力ファイル作成について
    ・make(path)で1ケース作るとする
    ・頂点数については記述がなかった（多分）ため、制約の中で一様分布とした
    ・V：頂点数、E：辺数（多分これもランダム）
    ・R、rの決定、座標の決定、ランダム化->coo(vi)=(x,y)
    これから
    ・MAKE_TREE：辺の構築。ユークリッド距離で最小全域木、残りのE-(V-1)本はまだ読んでない
    ・注文頻度の決定
    ・注文内容の決定
    ・書き込み

    ２．問題の考察
    まずスコアの計算について
    入力：移動クエリT=10^4
    店にいる場合：注文を受け取り、顧客スタックに注文時間を保存（注文スタック回）
    顧客にいる場合：顧客スタックだけ配達が完了し効用を計算する（顧客スタック回）
    厳密には顧客スタックと注文スタックは同じ配列で行える
    注文数に対して最大で2回の参照のため、計算量は注文数*2+T

    少なくとも店舗からすべての顧客への最短距離と最短ルートを計算する必要がある


    ３．問題A
    移動ルートを乱択し、改善する焼きなまし法を考える。
    移動ルートを事前に決定し変更するが、辺がない場合に注意
    ・あらかじめ最短ルートを計算しておいて
    向かうルートと通るルートを分ける。
    ・通るルート通りにクエリを生成して、Tmaxで終わる。

    店以外でstayする必要はないため、店ならば移動orstay
    顧客なら移動というように乱択する
    変更する場合は後ろすべてを乱択にする（前から決定する）

    30secあるのでかなりループできる

    ４．問題B
    Bでは全体への山登り法は使えず貪欲になる
    
    次の行動をしたとき、全体の利益が最大になるように移動する
    行動を決定する要素は
    ・注文スタックの数：多いほど店舗へ戻ろうとする
    ・移動先の顧客スタックの数：多いほど向かおうとする
    ・残り時間：いらないかも
    ・移動先の距離：遠いほど移動したがらない

    ？：辺の上で引き返す条件：とりあえず引き返さないとしてみる
    ？：店舗でstayする：注文数＝（顧客スタックの合計）が少ない場合。はじめはナシでもいいかも